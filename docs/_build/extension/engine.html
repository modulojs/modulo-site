<!DOCTYPE html><html>
        <head>
            <meta charset="utf8"><script src="../static/Modulo.html"></script><meta name="charset" charset="utf8" id="include_xxm0qoac"><meta name="content-type" http-equiv="Content-Type" content="text/html; charset=utf-8" id="include_xxnd8o0e"><meta name="viewport" content="width=device-width, initial-scale=1" id="include_x13l7u56"><meta name="robots" content="index, follow" id="include_xxriq75n"><meta name="revisit-after" content="30 days" id="include_x1m4jm9p">
            
                <script src="../static/Modulo.html"></script>
            
            <link rel="stylesheet" href="../buildpartial-xxpik5e0.css">
            <script defer="" src="../buildpartial-x1fkkq3q.js"></script>
        </head>
        <body>
            
            
        <meta charset="utf8">
        <title>Custom Engines - Modulo Documentation</title>
    
    <div class="layout Page">
        <nav class="page-nav Page">
            <a style="font-size:60px;text-align:center;display:block;font-weight:200" href="../" class="Page">ᵐ°dᵘ⁄o</a>
            <ul style="position: sticky; top: 1px" class="Page">
                <li class="toc--outer Page">
                    <p><a style="font-size: 70%" title="Download Modulo Docs as a offline-friendly zip" href="https://codeberg.org/modulo/docs/archive/main.zip" class="Page">
                            ⤓ docs-main.zip</a>
                        <tt>v0.1.0</tt>
                    </p>
                </li>
                
                    <li class="toc--outer Page"><h3 class="Page">       Modulo</h3></li>
                    <li class="toc--"><a href="../start/index.html" class="Page">           Introduction</a></li>
                
                    
                    <li class="toc--"><a href="../start/getting-started.html" class="Page"> Getting Started</a></li>
                
                    <li class="toc--outer Page"><h3 class="Page">           Definitions</h3></li>
                    <li class="toc--"><a href="../defs/overview.html" class="Page">         Overview</a></li>
                
                    
                    <li class="toc--"><a href="../defs/importing.html" class="Page">        Importing</a></li>
                
                    
                    <li class="toc--"><a href="../defs/definitions.html" class="Page">      Definition Types</a></li>
                
                    
                    <li class="toc--"><a href="../defs/processors.html" class="Page">       Processors</a></li>
                
                    
                    <li class="toc--"><a href="../defs/custom.html" class="Page">           Custom Types</a></li>
                
                    <li class="toc--outer Page"><h3 class="Page">  Templating</h3></li>
                    <li class="toc--"><a href="../templating/index.html" class="Page">      Language Overview</a></li>
                
                    
                    <li class="toc--"><a href="../templating/filters.html" class="Page">    Template Filters</a></li>
                
                    
                    <li class="toc--"><a href="../templating/tags.html" class="Page">       Template Tags</a></li>
                
                    <li class="toc--outer Page"><h3 class="Page">              Component Parts</h3></li>
                    <li class="toc--"><a href="../parts/props.html" class="Page">           Props</a></li>
                
                    
                    <li class="toc--"><a href="../parts/script.html" class="Page">          Script</a></li>
                
                    
                    <li class="toc--"><a href="../parts/state.html" class="Page">           State</a></li>
                
                    
                    <li class="toc--"><a href="../parts/staticdata.html" class="Page">      StaticData</a></li>
                
                    
                    <li class="toc--"><a href="../parts/style.html" class="Page">           Style</a></li>
                
                    
                    <li class="toc--"><a href="../parts/template.html" class="Page">        Template</a></li>
                
                    <li class="toc--outer Page"><h3 class="Page">           Core Definitions</h3></li>
                    <li class="toc--"><a href="../core/artifact.html" class="Page">         Artifact</a></li>
                
                    
                    <li class="toc--"><a href="../core/component.html" class="Page">        Component</a></li>
                
                    
                    <li class="toc--"><a href="../core/configuration.html" class="Page">    Configuration</a></li>
                
                    
                    <li class="toc--"><a href="../core/contentlist.html" class="Page">      ContentList</a></li>
                
                    
                    <li class="toc--"><a href="../core/include.html" class="Page">          Include</a></li>
                
                    
                    <li class="toc--"><a href="../core/library.html" class="Page">          Library</a></li>
                
                    <li class="toc--outer Page"><h3 class="Page">  Extension</h3></li>
                    <li class="toc--active Page"><a href="../extension/engine.html" class="Page">      Upgrading Engines</a></li>
                
            </ul>
        </nav>
        <main class="page-container Page">
            
                
                    
                        <x-tableofcontents toc="[{&quot;match&quot;:&quot;&lt;h1 id=\&quot;customdomcursor\&quot;&gt;Custom DOMCursor&lt;/h1&gt;&quot;,&quot;level&quot;:1,&quot;attrs&quot;:&quot;id=\&quot;customdomcursor\&quot;&quot;,&quot;title&quot;:&quot;Custom DOMCursor&quot;,&quot;id&quot;:&quot;customdomcursor&quot;},{&quot;match&quot;:&quot;&lt;h2 id=\&quot;motivationoptimizinglargecomponents\&quot;&gt;Motivation: Optimizing large components&lt;/h2&gt;&quot;,&quot;level&quot;:2,&quot;attrs&quot;:&quot;id=\&quot;motivationoptimizinglargecomponents\&quot;&quot;,&quot;title&quot;:&quot;Motivation: Optimizing large components&quot;,&quot;id&quot;:&quot;motivationoptimizinglargecomponents&quot;},{&quot;match&quot;:&quot;&lt;h2 id=\&quot;example1addingexamplesimplecustomlogic\&quot;&gt;Example 1: Adding example simple custom logic&lt;/h2&gt;&quot;,&quot;level&quot;:2,&quot;attrs&quot;:&quot;id=\&quot;example1addingexamplesimplecustomlogic\&quot;&quot;,&quot;title&quot;:&quot;Example 1: Adding example simple custom logic&quot;,&quot;id&quot;:&quot;example1addingexamplesimplecustomlogic&quot;},{&quot;match&quot;:&quot;&lt;h2 id=\&quot;example2upgradingtokeyedcursorforkeysupport\&quot;&gt;Example 2: Upgrading to KeyedCursor for key= support&lt;/h2&gt;&quot;,&quot;level&quot;:2,&quot;attrs&quot;:&quot;id=\&quot;example2upgradingtokeyedcursorforkeysupport\&quot;&quot;,&quot;title&quot;:&quot;Example 2: Upgrading to KeyedCursor for key= support&quot;,&quot;id&quot;:&quot;example2upgradingtokeyedcursorforkeysupport&quot;}]" modulo-mount-html=""><nav class="regular&quot;=&quot;">
        <div> </div>
        <div>
            <div>
                <label>[ <input name="show" type="checkbox"> Table of Contents ]</label>
                <label title="Stick to upper right">[ <span alt="upper right arrow">↗</span>
                    <input name="sticky" type="checkbox"> ]</label>
            </div>
            
                <ul>
                    
                        
                            <li style="--level: 1">
                                    <a href="#customdomcursor">Custom DOMCursor</a>
                            </li>
                        
                    
                        
                            <li style="--level: 2">
                                    <a href="#motivationoptimizinglargecomponents">Motivation: Optimizing large components</a>
                            </li>
                        
                    
                        
                            <li style="--level: 2">
                                    <a href="#example1addingexamplesimplecustomlogic">Example 1: Adding example simple custom logic</a>
                            </li>
                        
                    
                        
                            <li style="--level: 2">
                                    <a href="#example2upgradingtokeyedcursorforkeysupport">Example 2: Upgrading to KeyedCursor for key= support</a>
                            </li>
                        
                    
                </ul>
            
        </div>
    </nav></x-tableofcontents>
                    
                    <div class="markdown-body"><h1 id="customdomcursor">Custom DOMCursor</h1>
<blockquote>
  <p><strong>Terminology</strong> - In the source code and docs, "child" refers to the existing
  element, and "rival" refers to the reference element attempting to be matched
  (e.g., virtual DOM). The role of the DOMCursor is to most "logically" match
  children elements to rival (VDOM) elements.</p>
</blockquote>
<p>The DOMCursor is in charge of matching elements when a component reconciles.
That is to say, when a component re-renders (e.g. a user clicks and modifies
something), it attempts to match the the newly rendered element generated from
the <code>dom</code> or <code>render</code> phase of the lifecycle (e.g. the virtual DOM), with it's
original in the real, existing DOM.</p>
<p>Modulo's modular design extends to DOM element pairing as well. By extending
the simple built-in DOMCursor, we can include basic reconciler features such as
keyed elements, like in React and other frameworks, or even more complex logic
if we so desire.</p>
<h2 id="motivationoptimizinglargecomponents">Motivation: Optimizing large components</h2>
<blockquote>
  <p><strong>When to optimize</strong> - Why do we want to do this? The purpose is if you know
  that Modulo's automatic reconciliation "guesses" are causing your program to
  be slow. This often happens when adding and removing elements in large,
  complex components with many elements in a row with the same tag name.
  Ideally, eleeents should simply be hidden or shown, so this is only useful if
  thye are actually getting removed and inserted in the DOM, and the default
  Modulo matching ends up caussing slow-downs.</p>
</blockquote>
<p>The main reason you will want to extend the DOMCursor class is for optimizing
large components that update often. This can happen in UX-intensive
applications, such as tables that get insertions, swaps, and deletions in the
middle. By writing custom code to better matching element, we can make fewer
DOM transformations.</p>
<h2 id="example1addingexamplesimplecustomlogic">Example 1: Adding example simple custom logic</h2>
<p>In the following example, we show how you can add custom logic specific to your
optimization needs or component, in this case to 1) skip over already-rendered
elements with the <code>skip-me</code> attribute, and 2) compare other elements with the
first element resolved when selecting with the <code>repalce-me-with</code> attribute.</p><x-quickdemo mode="modulo" value="&lt;script Configuration&gt;
modulo.engine.CustomCursor = class CustomCursor extends modulo.engine.DOMCursor {
    next() {
        let [ child, rival ] = super.next() // Get default behavior
        if (child.hasAttribute('skip-me')) { // e.g. custom logic
            this.nextRival = rival // ensure rival gets repeated
            return this.next() // skip over child
        }
        if (rival.hasAttribute('replace-me-with')) { // e.g. other custom logic
            rival = document.querySelector(rival.getAttribute('replace-me-with'))
        }
        return [ child, rival ];
    }
}
&lt;/script&gt;
" modulo-mount-html=""><div class="editor-layout" style="--demo-width: 0px;">
        
            <x-syntaxhighlighter mode="modulo" value="&lt;script Configuration&gt;
modulo.engine.CustomCursor = class CustomCursor extends modulo.engine.DOMCursor {
    next() {
        let [ child, rival ] = super.next() // Get default behavior
        if (child.hasAttribute('skip-me')) { // e.g. custom logic
            this.nextRival = rival // ensure rival gets repeated
            return this.next() // skip over child
        }
        if (rival.hasAttribute('replace-me-with')) { // e.g. other custom logic
            rival = document.querySelector(rival.getAttribute('replace-me-with'))
        }
        return [ child, rival ];
    }
}
&lt;/script&gt;
" style="font-size: 18px" modulo-mount-html=""><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-modulo-deftype-attr">Configuration</span>&gt;</span><span class="language-javascript">
modulo.<span class="hljs-property">engine</span>.<span class="hljs-property">CustomCursor</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomCursor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">modulo.engine.DOMCursor</span> {
    <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">let</span> [ child, rival ] = <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Get default behavior</span>
        <span class="hljs-keyword">if</span> (child.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">'skip-me'</span>)) { <span class="hljs-comment">// e.g. custom logic</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextRival</span> = rival <span class="hljs-comment">// ensure rival gets repeated</span>
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// skip over child</span>
        }
        <span class="hljs-keyword">if</span> (rival.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-string">'replace-me-with'</span>)) { <span class="hljs-comment">// e.g. other custom logic</span>
            rival = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(rival.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'replace-me-with'</span>))
        }
        <span class="hljs-keyword">return</span> [ child, rival ];
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</span></x-syntaxhighlighter>
        
        <div class="toolbar toolbar--small toolbar--autohide
             toolbar--snippet">
            
                <button><span alt="Clipboard icon">📋</span> Copy</button>
            
        </div>
        
    </div>
    <div class="overlay"></div></x-quickdemo>
<h2 id="example2upgradingtokeyedcursorforkeysupport">Example 2: Upgrading to KeyedCursor for key= support</h2>
<p>By extending the above to keep track of "keyed" elements into the following
class, we can create a <code>KeyedCursor</code> that supports the keyed element matching
feature when activated, for huge speed improvements when used correctly, and
only very little extra overhead compared to the default DOMCursor:</p><x-quickdemo mode="modulo" value="&lt;script Configuration&gt;
modulo.engine.KeyCursor = class KeyCursor extends modulo.engine.DOMCursor {
    initialize(parentNode, parentRival) {
        super.initialize(parentNode, parentRival);
        this.keyedChildren = {}; // Setup an object for children with keys
        this.keyedRivals = {}; // and ditto for rivals
    }

    _getMatchedNode(elem, keyedElems, keyedOthers) {
        const key = elem &amp;&amp; elem.nodeType === 1 &amp;&amp; elem.getAttribute('key');
        if (!key) {
            return null;
        } else if (key in keyedOthers) {
            const matched = keyedOthers[key];
            delete keyedOthers[key];
            return matched;
        } else if (key in keyedElems) {
            console.warn('MODULO: Duplicate key:', key);
        }
        keyedElems[key] = elem;
        return false;
    }

    _hasNextInExcessKeys() { // There were &quot;excess&quot;, unmatched keyed elements
        if (!this.activeExcess) { // Convert needed appends and removes to array
            const child = Object.values(this.keyedChildren).map(v =&gt; [v, null]);
            const rival = Object.values(this.keyedRivals).map(v =&gt; [null, v]);
            this.activeExcess = rival.concat(child); // Do appends before remove
        }
        return this.activeExcess.length &gt; 0; // Return true if there is any left
    }

    hasNext() {
        if (this.nextChild || this.nextRival || this._hasNextInExcessKeys()) {
            return true; // Is pointing at another node, or has unmatched keys
        } else {
            return super.hasNext(); // Fall back on DOMCursor logic for slots
        }
    }

    next() {
        if (!this.nextRival &amp;&amp; this.activeExcess &amp;&amp; this.activeExcess.length &gt; 0) { 
            return this.activeExcess.shift(); // Return first pair (base logic)
        }
        let [ child, rival ] = super.next() // Get default behavior
        let matchedRival = this._getMatchedNode(child, this.keyedChildren, this.keyedRivals);
        let matchedChild = this._getMatchedNode(rival, this.keyedRivals, this.keyedChildren);
        if (matchedRival === false) { // Child has a key, but does not match
            child = this.nextChild; // Simply ignore Child, and on to next
            this.nextChild = child ? child.nextSibling : null;
        } else if (matchedChild === false) { // Rival has key, but no match
            rival = this.nextRival; // IGNORE rival - move on to
            this._setNextRival(rival); // (and setup next-next rival)
        }
        const keyWasFound = matchedRival !== null || matchedChild !== null;
        const matchFound = matchedChild !== child &amp;&amp; keyWasFound;
        if (matchFound &amp;&amp; matchedChild) { // Rival matches, but not child
            this.nextChild = child; // &quot;Undo&quot; this last &quot;nextChild&quot; (return)
            child = matchedChild; // Then substitute the matched instead
        }
        if (matchFound &amp;&amp; matchedRival) {
            // Child matches, but not with rival. Swap in the correct one.
            this.nextRival = rival; // &quot;Undo&quot; this last &quot;nextRival&quot;
            rival = matchedRival; // Then substitute the matched rival
        }
        return [ child, rival ];
    }
}

// To enable universally:
// modulo.cursor.DOMCursor = modulo.cursor.KeyCursor
&lt;/script&gt;
" modulo-mount-html=""><div class="editor-layout" style="--demo-width: 0px;">
        
            <x-syntaxhighlighter mode="modulo" value="&lt;script Configuration&gt;
modulo.engine.KeyCursor = class KeyCursor extends modulo.engine.DOMCursor {
    initialize(parentNode, parentRival) {
        super.initialize(parentNode, parentRival);
        this.keyedChildren = {}; // Setup an object for children with keys
        this.keyedRivals = {}; // and ditto for rivals
    }

    _getMatchedNode(elem, keyedElems, keyedOthers) {
        const key = elem &amp;&amp; elem.nodeType === 1 &amp;&amp; elem.getAttribute('key');
        if (!key) {
            return null;
        } else if (key in keyedOthers) {
            const matched = keyedOthers[key];
            delete keyedOthers[key];
            return matched;
        } else if (key in keyedElems) {
            console.warn('MODULO: Duplicate key:', key);
        }
        keyedElems[key] = elem;
        return false;
    }

    _hasNextInExcessKeys() { // There were &quot;excess&quot;, unmatched keyed elements
        if (!this.activeExcess) { // Convert needed appends and removes to array
            const child = Object.values(this.keyedChildren).map(v =&gt; [v, null]);
            const rival = Object.values(this.keyedRivals).map(v =&gt; [null, v]);
            this.activeExcess = rival.concat(child); // Do appends before remove
        }
        return this.activeExcess.length &gt; 0; // Return true if there is any left
    }

    hasNext() {
        if (this.nextChild || this.nextRival || this._hasNextInExcessKeys()) {
            return true; // Is pointing at another node, or has unmatched keys
        } else {
            return super.hasNext(); // Fall back on DOMCursor logic for slots
        }
    }

    next() {
        if (!this.nextRival &amp;&amp; this.activeExcess &amp;&amp; this.activeExcess.length &gt; 0) { 
            return this.activeExcess.shift(); // Return first pair (base logic)
        }
        let [ child, rival ] = super.next() // Get default behavior
        let matchedRival = this._getMatchedNode(child, this.keyedChildren, this.keyedRivals);
        let matchedChild = this._getMatchedNode(rival, this.keyedRivals, this.keyedChildren);
        if (matchedRival === false) { // Child has a key, but does not match
            child = this.nextChild; // Simply ignore Child, and on to next
            this.nextChild = child ? child.nextSibling : null;
        } else if (matchedChild === false) { // Rival has key, but no match
            rival = this.nextRival; // IGNORE rival - move on to
            this._setNextRival(rival); // (and setup next-next rival)
        }
        const keyWasFound = matchedRival !== null || matchedChild !== null;
        const matchFound = matchedChild !== child &amp;&amp; keyWasFound;
        if (matchFound &amp;&amp; matchedChild) { // Rival matches, but not child
            this.nextChild = child; // &quot;Undo&quot; this last &quot;nextChild&quot; (return)
            child = matchedChild; // Then substitute the matched instead
        }
        if (matchFound &amp;&amp; matchedRival) {
            // Child matches, but not with rival. Swap in the correct one.
            this.nextRival = rival; // &quot;Undo&quot; this last &quot;nextRival&quot;
            rival = matchedRival; // Then substitute the matched rival
        }
        return [ child, rival ];
    }
}

// To enable universally:
// modulo.cursor.DOMCursor = modulo.cursor.KeyCursor
&lt;/script&gt;
" style="font-size: 18px" modulo-mount-html=""><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-modulo-deftype-attr">Configuration</span>&gt;</span><span class="language-javascript">
modulo.<span class="hljs-property">engine</span>.<span class="hljs-property">KeyCursor</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyCursor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">modulo.engine.DOMCursor</span> {
    <span class="hljs-title function_">initialize</span>(<span class="hljs-params">parentNode, parentRival</span>) {
        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">initialize</span>(parentNode, parentRival);
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedChildren</span> = {}; <span class="hljs-comment">// Setup an object for children with keys</span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedRivals</span> = {}; <span class="hljs-comment">// and ditto for rivals</span>
    }

    <span class="hljs-title function_">_getMatchedNode</span>(<span class="hljs-params">elem, keyedElems, keyedOthers</span>) {
        <span class="hljs-keyword">const</span> key = elem &amp;&amp; elem.<span class="hljs-property">nodeType</span> === <span class="hljs-number">1</span> &amp;&amp; elem.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">'key'</span>);
        <span class="hljs-keyword">if</span> (!key) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> keyedOthers) {
            <span class="hljs-keyword">const</span> matched = keyedOthers[key];
            <span class="hljs-keyword">delete</span> keyedOthers[key];
            <span class="hljs-keyword">return</span> matched;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> keyedElems) {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">'MODULO: Duplicate key:'</span>, key);
        }
        keyedElems[key] = elem;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-title function_">_hasNextInExcessKeys</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">// There were "excess", unmatched keyed elements</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">activeExcess</span>) { <span class="hljs-comment">// Convert needed appends and removes to array</span>
            <span class="hljs-keyword">const</span> child = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedChildren</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> [v, <span class="hljs-literal">null</span>]);
            <span class="hljs-keyword">const</span> rival = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedRivals</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> [<span class="hljs-literal">null</span>, v]);
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeExcess</span> = rival.<span class="hljs-title function_">concat</span>(child); <span class="hljs-comment">// Do appends before remove</span>
        }
        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeExcess</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-comment">// Return true if there is any left</span>
    }

    <span class="hljs-title function_">hasNext</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">nextChild</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextRival</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_hasNextInExcessKeys</span>()) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// Is pointing at another node, or has unmatched keys</span>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">hasNext</span>(); <span class="hljs-comment">// Fall back on DOMCursor logic for slots</span>
        }
    }

    <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">nextRival</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeExcess</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeExcess</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) { 
            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">activeExcess</span>.<span class="hljs-title function_">shift</span>(); <span class="hljs-comment">// Return first pair (base logic)</span>
        }
        <span class="hljs-keyword">let</span> [ child, rival ] = <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">next</span>() <span class="hljs-comment">// Get default behavior</span>
        <span class="hljs-keyword">let</span> matchedRival = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_getMatchedNode</span>(child, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedChildren</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedRivals</span>);
        <span class="hljs-keyword">let</span> matchedChild = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_getMatchedNode</span>(rival, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedRivals</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keyedChildren</span>);
        <span class="hljs-keyword">if</span> (matchedRival === <span class="hljs-literal">false</span>) { <span class="hljs-comment">// Child has a key, but does not match</span>
            child = <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextChild</span>; <span class="hljs-comment">// Simply ignore Child, and on to next</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextChild</span> = child ? child.<span class="hljs-property">nextSibling</span> : <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matchedChild === <span class="hljs-literal">false</span>) { <span class="hljs-comment">// Rival has key, but no match</span>
            rival = <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextRival</span>; <span class="hljs-comment">// IGNORE rival - move on to</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">_setNextRival</span>(rival); <span class="hljs-comment">// (and setup next-next rival)</span>
        }
        <span class="hljs-keyword">const</span> keyWasFound = matchedRival !== <span class="hljs-literal">null</span> || matchedChild !== <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">const</span> matchFound = matchedChild !== child &amp;&amp; keyWasFound;
        <span class="hljs-keyword">if</span> (matchFound &amp;&amp; matchedChild) { <span class="hljs-comment">// Rival matches, but not child</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextChild</span> = child; <span class="hljs-comment">// "Undo" this last "nextChild" (return)</span>
            child = matchedChild; <span class="hljs-comment">// Then substitute the matched instead</span>
        }
        <span class="hljs-keyword">if</span> (matchFound &amp;&amp; matchedRival) {
            <span class="hljs-comment">// Child matches, but not with rival. Swap in the correct one.</span>
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextRival</span> = rival; <span class="hljs-comment">// "Undo" this last "nextRival"</span>
            rival = matchedRival; <span class="hljs-comment">// Then substitute the matched rival</span>
        }
        <span class="hljs-keyword">return</span> [ child, rival ];
    }
}

<span class="hljs-comment">// To enable universally:</span>
<span class="hljs-comment">// modulo.cursor.DOMCursor = modulo.cursor.KeyCursor</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</span></x-syntaxhighlighter>
        
        <div class="toolbar toolbar--small toolbar--autohide
             toolbar--snippet">
            
                <button><span alt="Clipboard icon">📋</span> Copy</button>
            
        </div>
        
    </div>
    <div class="overlay"></div></x-quickdemo>
</div>
                
            
        </main>
    </div>
            
        </body>
    </html>